#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

#-------------------------------------------------------------------------------
# CONFIGURATION (Modify for your authorized environment)
#-------------------------------------------------------------------------------
readonly SCRIPT_VERSION="1.0.0"
readonly SCRIPT_NAME="safe-recon-mvp"

# Rate limiting and concurrency
RATE_LIMIT="${RATE_LIMIT:-2}"           # Requests per second per target
CONCURRENCY="${CONCURRENCY:-5}"          # Max parallel targets
REQUEST_TIMEOUT="${REQUEST_TIMEOUT:-10}" # Seconds
MAX_RETRIES="${MAX_RETRIES:-2}"
RETRY_DELAY="${RETRY_DELAY:-3}"

# Output configuration
OUTPUT_DIR="${OUTPUT_DIR:-./recon_output}"
OUTPUT_FORMAT="${OUTPUT_FORMAT:-jsonl}"  # jsonl or csv
VERBOSE="${VERBOSE:-false}"
RESPECT_ROBOTS="${RESPECT_ROBOTS:-true}"

# User agent (identify as security scanner - good practice)
USER_AGENT="SafeReconMVP/${SCRIPT_VERSION} (Authorized Security Assessment)"

# TODO: Add authorized OOB callback domain for controlled canary detection
# OOB_DOMAIN=""  # e.g., your Burp Collaborator or interactsh instance
# WARNING: Only use OOB if you control the callback infrastructure

#-------------------------------------------------------------------------------
# SIGNATURE DATABASE
# Format: "VULN_CLASS:identifier:version_pattern:confidence_boost"
# Extend this with your own research; NEVER add exploit payloads
#-------------------------------------------------------------------------------
declare -A VULN_SIGNATURES=(
    # Spring4Shell indicators (CVE-2022-22965)
    ["spring4shell:header:X-Application-Context"]="MEDIUM:Spring application context detected"
    ["spring4shell:header:Spring-Boot-Version"]="HIGH:Spring Boot version header found"
    ["spring4shell:body:Whitelabel Error Page"]="MEDIUM:Spring Boot default error page"
    ["spring4shell:body:springframework"]="LOW:Spring Framework reference in response"
    ["spring4shell:endpoint:/actuator/env"]="MEDIUM:Spring Actuator env endpoint accessible"
    ["spring4shell:endpoint:/actuator/info"]="LOW:Spring Actuator info endpoint accessible"
    ["spring4shell:endpoint:/actuator/health"]="LOW:Spring Actuator health endpoint"
    
    # Log4Shell indicators (CVE-2021-44228)
    ["log4shell:manifest:log4j-core"]="HIGH:Log4j-core found in manifest/pom"
    ["log4shell:manifest:log4j-api"]="MEDIUM:Log4j-api found in manifest/pom"
    ["log4shell:version:2\\.[0-9]\\.[0-9]"]="MEDIUM:Log4j 2.x version pattern detected"
    ["log4shell:version:2\\.([0-9]|1[0-6])\\.[0-9]"]="HIGH:Log4j version < 2.17 pattern"
    ["log4shell:body:log4j"]="LOW:Log4j reference in response body"
    ["log4shell:error:org.apache.logging.log4j"]="MEDIUM:Log4j package in error trace"
    
    # Text4Shell indicators (CVE-2022-42889)
    ["text4shell:manifest:commons-text"]="MEDIUM:Apache Commons Text in dependencies"
    ["text4shell:version:1\\.[5-9]\\.[0-9]"]="HIGH:Commons Text 1.5-1.9 (vulnerable range)"
    ["text4shell:pom:commons-text"]="MEDIUM:Commons Text in pom.xml"
    
    # Fastjson indicators
    ["fastjson:header:Fastjson"]="HIGH:Fastjson header detected"
    ["fastjson:body:com.alibaba.fastjson"]="MEDIUM:Fastjson package reference"
    ["fastjson:error:JSONException"]="LOW:Fastjson JSON exception pattern"
    ["fastjson:body:@type"]="MEDIUM:Fastjson @type indicator in JSON"
    
    # Jackson deserialization indicators
    ["jackson:manifest:jackson-databind"]="MEDIUM:Jackson-databind in dependencies"
    ["jackson:body:@class]="LOW:Jackson polymorphic type indicator"
    ["jackson:error:JsonMappingException"]="MEDIUM:Jackson mapping exception"
    ["jackson:error:com.fasterxml.jackson"]="MEDIUM:Jackson package in error"
    ["jackson:version:2\\.[0-8]\\.[0-9]"]="MEDIUM:Older Jackson 2.x version"
    
    # Apache Struts 2 indicators (CVE-2017-5638)
    ["struts:endpoint:\\.action$"]="MEDIUM:Struts .action endpoint found"
    ["struts:endpoint:\\.do$"]="LOW:Possible Struts .do endpoint"
    ["struts:body:struts\\.devMode"]="HIGH:Struts devMode reference"
    ["struts:error:ognl\\.OgnlException"]="HIGH:OGNL exception in error"
    ["struts:error:org\\.apache\\.struts"]="MEDIUM:Struts package in error trace"
    ["struts:header:Struts"]="HIGH:Struts header detected"
    ["struts:body:struts-tags"]="MEDIUM:Struts tags library reference"
    
    # Kibana prototype pollution (CVE-2019-7609)
    ["kibana:endpoint:/api/status"]="MEDIUM:Kibana API status endpoint"
    ["kibana:body:\"version\".*\"number\""]="MEDIUM:Kibana version in JSON"
    ["kibana:body:\"6\\.[0-5]\\.[0-9]\""]="HIGH:Kibana 6.0-6.5 (vulnerable)"
    ["kibana:body:\"5\\.[0-6]\\.[0-9]\""]="HIGH:Kibana 5.x (vulnerable)"
    ["kibana:endpoint:/app/kibana"]="LOW:Kibana app endpoint"
    
    # Ghostscript/ImageMagick indicators
    ["imagemagick:header:X-ImageMagick"]="HIGH:ImageMagick header detected"
    ["imagemagick:endpoint:/convert"]="LOW:Possible image conversion endpoint"
    ["imagemagick:error:ImageMagick"]="MEDIUM:ImageMagick in error message"
    ["imagemagick:error:Ghostscript"]="MEDIUM:Ghostscript in error message"
    ["ghostscript:body:GPL Ghostscript"]="MEDIUM:Ghostscript version in response"
    
    # vm2 sandbox escape (Node.js)
    ["vm2:manifest:\"vm2\""]="HIGH:vm2 package in package.json"
    ["vm2:version:\"vm2\":.*\"3\\.[0-8]"]="HIGH:vm2 < 3.9 (vulnerable versions)"
    ["vm2:lockfile:vm2@"]="MEDIUM:vm2 in package-lock.json"
)

# Vulnerable version ranges (for cross-referencing)
declare -A VULNERABLE_VERSIONS=(
    ["log4j-core"]="2.0-beta9:2.17.0"
    ["commons-text"]="1.5:1.9"
    ["spring-boot"]="2.0.0:2.5.12|2.6.0:2.6.6"
    ["jackson-databind"]="2.0.0:2.9.10.8"
    ["kibana"]="5.0.0:6.6.0"
    ["vm2"]="0.0.0:3.9.10"
)

#-------------------------------------------------------------------------------
# LOGGING AND OUTPUT FUNCTIONS
#-------------------------------------------------------------------------------
log_info() { echo "[INFO] $(date -Iseconds) $*" >&2; }
log_warn() { echo "[WARN] $(date -Iseconds) $*" >&2; }
log_error() { echo "[ERROR] $(date -Iseconds) $*" >&2; }
log_debug() { [[ "$VERBOSE" == "true" ]] && echo "[DEBUG] $(date -Iseconds) $*" >&2 || true; }

# Initialize output directory and files
init_output() {
    mkdir -p "$OUTPUT_DIR"
    RESULTS_FILE="$OUTPUT_DIR/results_$(date +%Y%m%d_%H%M%S).jsonl"
    SUMMARY_FILE="$OUTPUT_DIR/summary_$(date +%Y%m%d_%H%M%S).txt"
    log_info "Output directory: $OUTPUT_DIR"
    log_info "Results file: $RESULTS_FILE"
    
    # Write header for CSV if needed
    if [[ "$OUTPUT_FORMAT" == "csv" ]]; then
        echo "timestamp,target,check_type,vuln_class,indicator,confidence,evidence" > "${RESULTS_FILE%.jsonl}.csv"
    fi
}

#-------------------------------------------------------------------------------
# RESULT REPORTING
# Outputs findings in machine-readable format with evidence
#-------------------------------------------------------------------------------
report_result() {
    local target="$1"
    local check_type="$2"
    local vuln_class="$3"
    local indicator="$4"
    local confidence="$5"  # LOW, MEDIUM, HIGH
    local evidence="$6"
    local explanation="$7"
    
    local timestamp
    timestamp=$(date -Iseconds)
    
    # Sanitize evidence (remove control chars, limit length)
    evidence=$(echo "$evidence" | tr -cd '[:print:]' | head -c 500)
    
    # JSON Lines output
    local json_record
    json_record=$(jq -n -c \
        --arg ts "$timestamp" \
        --arg tgt "$target" \
        --arg ct "$check_type" \
        --arg vc "$vuln_class" \
        --arg ind "$indicator" \
        --arg conf "$confidence" \
        --arg ev "$evidence" \
        --arg exp "$explanation" \
        '{
            timestamp: $ts,
            target: $tgt,
            check_type: $ct,
            vuln_class: $vc,
            indicator: $ind,
            confidence: $conf,
            evidence: $ev,
            explanation: $exp
        }')
    
    echo "$json_record" >> "$RESULTS_FILE"
    
    # Human-readable output
    if [[ "$VERBOSE" == "true" ]]; then
        echo "[$confidence] $vuln_class :: $indicator @ $target"
        echo "    Evidence: ${evidence:0:100}..."
    fi
}

#-------------------------------------------------------------------------------
# CONFIDENCE SCORING ENGINE
# Aggregates multiple indicators into final confidence
#-------------------------------------------------------------------------------
declare -A INDICATOR_SCORES
INDICATOR_SCORES=( ["LOW"]=1 ["MEDIUM"]=3 ["HIGH"]=5 )

calculate_confidence() {
    local -n indicators=$1  # nameref to array of "CONFIDENCE:indicator" strings
    local total_score=0
    local high_count=0
    local med_count=0
    
    for item in "${indicators[@]}"; do
        local conf="${item%%:*}"
        case "$conf" in
            HIGH)   ((total_score += 5)); ((high_count++)) ;;
            MEDIUM) ((total_score += 3)); ((med_count++)) ;;
            LOW)    ((total_score += 1)) ;;
        esac
    done
    
    # Scoring rules:
    # - Any HIGH indicator alone = HIGH confidence
    # - 2+ MEDIUM indicators = HIGH confidence
    # - 1 MEDIUM + 2 LOW = MEDIUM confidence
    # - Otherwise proportional to score
    
    if [[ $high_count -ge 1 ]]; then
        echo "HIGH"
    elif [[ $med_count -ge 2 ]]; then
        echo "HIGH"
    elif [[ $total_score -ge 5 ]]; then
        echo "MEDIUM"
    elif [[ $total_score -ge 2 ]]; then
        echo "LOW"
    else
        echo "INFO"
    fi
}

#-------------------------------------------------------------------------------
# HTTP REQUEST WRAPPER
# Handles rate limiting, retries, and safe request patterns
#-------------------------------------------------------------------------------
declare -A ROBOTS_CACHE

http_get() {
    local url="$1"
    local output_file="$2"
    local headers_file="${3:-}"
    local retry_count=0
    
    # Rate limiting (simple token bucket approximation)
    sleep "$(echo "scale=2; 1/$RATE_LIMIT" | bc)"
    
    while [[ $retry_count -lt $MAX_RETRIES ]]; do
        local curl_opts=(
            --silent
            --show-error
            --location
            --max-time "$REQUEST_TIMEOUT"
            --max-redirs 5
            --user-agent "$USER_AGENT"
            --output "$output_file"
            --write-out "%{http_code}"
        )
        
        if [[ -n "$headers_file" ]]; then
            curl_opts+=(--dump-header "$headers_file")
        fi
        
        local http_code
        http_code=$(curl "${curl_opts[@]}" "$url" 2>/dev/null) || http_code="000"
        
        if [[ "$http_code" =~ ^[23] ]]; then
            echo "$http_code"
            return 0
        elif [[ "$http_code" == "429" ]]; then
            log_warn "Rate limited on $url, backing off..."
            sleep "$((RETRY_DELAY * (retry_count + 1)))"
        elif [[ "$http_code" == "000" ]]; then
            log_debug "Connection failed to $url"
        fi
        
        ((retry_count++))
        sleep "$RETRY_DELAY"
    done
    
    echo "$http_code"
    return 1
}

http_head() {
    local url="$1"
    local headers_file="$2"
    
    sleep "$(echo "scale=2; 1/$RATE_LIMIT" | bc)"
    
    curl --silent --show-error --head \
        --max-time "$REQUEST_TIMEOUT" \
        --user-agent "$USER_AGENT" \
        --output "$headers_file" \
        "$url" 2>/dev/null
    
    return $?
}

#-------------------------------------------------------------------------------
# ROBOTS.TXT RESPECT
# Check if path is disallowed before requesting
#-------------------------------------------------------------------------------
check_robots_allowed() {
    local target="$1"
    local path="$2"
    
    [[ "$RESPECT_ROBOTS" != "true" ]] && return 0
    
    local base_url
    base_url=$(echo "$target" | grep -oP '^https?://[^/]+')
    
    if [[ -z "${ROBOTS_CACHE[$base_url]:-}" ]]; then
        local robots_file
        robots_file=$(mktemp)
        if http_get "${base_url}/robots.txt" "$robots_file" >/dev/null 2>&1; then
            ROBOTS_CACHE[$base_url]=$(cat "$robots_file")
        else
            ROBOTS_CACHE[$base_url]="NONE"
        fi
        rm -f "$robots_file"
    fi
    
    local robots_content="${ROBOTS_CACHE[$base_url]}"
    [[ "$robots_content" == "NONE" ]] && return 0
    
    # Simple check - if path is explicitly disallowed, skip
    if echo "$robots_content" | grep -qiE "^Disallow:.*${path}"; then
        log_debug "Path $path disallowed by robots.txt on $base_url"
        return 1
    fi
    
    return 0
}

#-------------------------------------------------------------------------------
# PROBE: HTTP HEADERS
# Extracts security-relevant headers for fingerprinting
#-------------------------------------------------------------------------------
probe_headers() {
    local target="$1"
    local headers_file="$2"
    local -n results=$3  # nameref to results array
    
    log_debug "Probing headers for: $target"
    
    http_head "$target" "$headers_file" || return 1
    
    # Extract relevant headers (case-insensitive)
    local server x_powered_by x_app_context x_aspnet x_runtime
    
    server=$(grep -i "^Server:" "$headers_file" 2>/dev/null | head -1 | cut -d: -f2- | xargs)
    x_powered_by=$(grep -i "^X-Powered-By:" "$headers_file" 2>/dev/null | head -1 | cut -d: -f2- | xargs)
    x_app_context=$(grep -i "^X-Application-Context:" "$headers_file" 2>/dev/null | head -1 | cut -d: -f2- | xargs)
    
    # Check signatures against extracted headers
    for sig_key in "${!VULN_SIGNATURES[@]}"; do
        local vuln_class check_type pattern
        IFS=':' read -r vuln_class check_type pattern <<< "$sig_key"
        
        [[ "$check_type" != "header" ]] && continue
        
        local sig_value="${VULN_SIGNATURES[$sig_key]}"
        local confidence explanation
        IFS=':' read -r confidence explanation <<< "$sig_value"
        
        # Check Server header
        if [[ -n "$server" ]] && echo "$server" | grep -qiE "$pattern"; then
            results+=("$confidence:header:$pattern")
            report_result "$target" "header_probe" "$vuln_class" \
                "$pattern" "$confidence" "Server: $server" "$explanation"
        fi
        
        # Check X-Powered-By
        if [[ -n "$x_powered_by" ]] && echo "$x_powered_by" | grep -qiE "$pattern"; then
            results+=("$confidence:header:$pattern")
            report_result "$target" "header_probe" "$vuln_class" \
                "$pattern" "$confidence" "X-Powered-By: $x_powered_by" "$explanation"
        fi
        
        # Check X-Application-Context (Spring indicator)
        if [[ -n "$x_app_context" ]] && [[ "$pattern" == "X-Application-Context" ]]; then
            results+=("$confidence:header:$pattern")
            report_result "$target" "header_probe" "$vuln_class" \
                "$pattern" "$confidence" "X-Application-Context: $x_app_context" "$explanation"
        fi
    done
}

#-------------------------------------------------------------------------------
# PROBE: SAFE ENDPOINTS
# Checks for known informational/metadata endpoints
#-------------------------------------------------------------------------------
probe_endpoints() {
    local target="$1"
    local -n results=$2
    
    # Define safe endpoints that expose version/config info
    local -a safe_endpoints=(
        "/actuator/info"
        "/actuator/health"
        "/actuator/env"
        "/api/status"
        "/api/info"
        "/app/kibana"
        "/.well-known/security.txt"
        "/server-status"
        "/version"
        "/info"
    )
    
    local base_url
    base_url=$(echo "$target" | sed 's|/$||')
    
    for endpoint in "${safe_endpoints[@]}"; do
        check_robots_allowed "$base_url" "$endpoint" || continue
        
        local response_file headers_file
        response_file=$(mktemp)
        headers_file=$(mktemp)
        
        local url="${base_url}${endpoint}"
        log_debug "Checking endpoint: $url"
        
        local http_code
        http_code=$(http_get "$url" "$response_file" "$headers_file")
        
        if [[ "$http_code" =~ ^2 ]]; then
            local body_snippet
            body_snippet=$(head -c 1000 "$response_file" | tr -cd '[:print:]')
            
            # Match against endpoint signatures
            for sig_key in "${!VULN_SIGNATURES[@]}"; do
                local vuln_class check_type pattern
                IFS=':' read -r vuln_class check_type pattern <<< "$sig_key"
                
                [[ "$check_type" != "endpoint" ]] && continue
                
                if echo "$endpoint" | grep -qE "$pattern"; then
                    local sig_value="${VULN_SIGNATURES[$sig_key]}"
                    local confidence explanation
                    IFS=':' read -r confidence explanation <<< "$sig_value"
                    
                    results+=("$confidence:endpoint:$endpoint")
                    report_result "$target" "endpoint_probe" "$vuln_class" \
                        "$endpoint" "$confidence" "HTTP $http_code - ${body_snippet:0:200}" "$explanation"
                fi
            done
            
            # Extract version information from JSON responses
            if echo "$body_snippet" | grep -qE '^\s*\{'; then
                extract_version_from_json "$body_snippet" "$target" results
            fi
        fi
        
        rm -f "$response_file" "$headers_file"
    done
}

#-------------------------------------------------------------------------------
# PROBE: DEPENDENCY FILES
# Checks for exposed dependency manifests (pom.xml, package.json, etc.)
#-------------------------------------------------------------------------------
probe_dependency_files() {
    local target="$1"
    local -n results=$2
    
    local -a dependency_files=(
        "/pom.xml"
        "/package.json"
        "/package-lock.json"
        "/build.gradle"
        "/META-INF/MANIFEST.MF"
        "/WEB-INF/web.xml"
        "/bower.json"
        "/composer.json"
        "/requirements.txt"
        "/Gemfile"
        "/Gemfile.lock"
    )
    
    local base_url
    base_url=$(echo "$target" | sed 's|/$||')
    
    for dep_file in "${dependency_files[@]}"; do
        check_robots_allowed "$base_url" "$dep_file" || continue
        
        local response_file
        response_file=$(mktemp)
        
        local url="${base_url}${dep_file}"
        local http_code
        http_code=$(http_get "$url" "$response_file")
        
        if [[ "$http_code" =~ ^2 ]]; then
            local content
            content=$(cat "$response_file" 2>/dev/null)
            
            log_info "Found dependency file: $url"
            
            # Check for vulnerable dependencies
            check_dependency_content "$content" "$dep_file" "$target" results
        fi
        
        rm -f "$response_file"
    done
}

#-------------------------------------------------------------------------------
# DEPENDENCY CONTENT ANALYZER
# Parses dependency files for vulnerable component versions
#-------------------------------------------------------------------------------
check_dependency_content() {
    local content="$1"
    local file_type="$2"
    local target="$3"
    local -n results=$4
    
    # Log4j detection in pom.xml / build.gradle
    if [[ "$file_type" =~ pom\.xml|build\.gradle ]]; then
        # Check for log4j-core
        if echo "$content" | grep -qiE "log4j-core|log4j-api"; then
            local version
            version=$(echo "$content" | grep -oP '(?<=<version>)[0-9.]+(?=</version>)' | head -1)
            version=${version:-$(echo "$content" | grep -oP "log4j.*?['\"]([0-9.]+)['\"]" | grep -oP '[0-9.]+' | head -1)}
            
            results+=("HIGH:manifest:log4j-core:$version")
            report_result "$target" "dependency_scan" "log4shell" \
                "log4j-core:$version" "HIGH" "$file_type contains log4j reference" \
                "Log4j found in build manifest - verify version against CVE-2021-44228"
        fi
        
        # Check for commons-text
        if echo "$content" | grep -qiE "commons-text"; then
            local version
            version=$(echo "$content" | grep -A2 -iE "commons-text" | grep -oP '(?<=<version>)[0-9.]+' | head -1)
            
            if [[ -n "$version" ]] && version_in_range "$version" "1.5" "1.9"; then
                results+=("HIGH:manifest:commons-text:$version")
                report_result "$target" "dependency_scan" "text4shell" \
                    "commons-text:$version" "HIGH" "$file_type contains vulnerable commons-text" \
                    "Apache Commons Text $version is vulnerable to CVE-2022-42889"
            fi
        fi
        
        # Check for jackson-databind
        if echo "$content" | grep -qiE "jackson-databind"; then
            results+=("MEDIUM:manifest:jackson-databind")
            report_result "$target" "dependency_scan" "jackson" \
                "jackson-databind" "MEDIUM" "$file_type contains jackson-databind" \
                "Jackson databind found - verify version for deserialization vulnerabilities"
        fi
    fi
    
    # Node.js package.json checks
    if [[ "$file_type" =~ package.*\.json ]]; then
        # Check for vm2
        if echo "$content" | grep -qE '"vm2"'; then
            local version
            version=$(echo "$content" | jq -r '.dependencies.vm2 // .devDependencies.vm2 // empty' 2>/dev/null)
            
            results+=("HIGH:manifest:vm2:$version")
            report_result "$target" "dependency_scan" "vm2" \
                "vm2:$version" "HIGH" "package.json contains vm2" \
                "vm2 sandbox found - check for CVE-2023-37466 and related escapes"
        fi
    fi
}

#-------------------------------------------------------------------------------
# PROBE: ERROR PAGE FINGERPRINTING
# Triggers safe error conditions to analyze stack traces/error messages
#-------------------------------------------------------------------------------
probe_error_pages() {
    local target="$1"
    local -n results=$2
    
    # Request non-existent paths to trigger error pages
    local -a error_triggers=(
        "/SAFE_RECON_404_TEST_$(date +%s)"
        "/..INVALID..PATH.."
        "/%00test"  # Null byte - safe, just triggers error handlers
    )
    
    local base_url
    base_url=$(echo "$target" | sed 's|/$||')
    
    for trigger in "${error_triggers[@]}"; do
        local response_file
        response_file=$(mktemp)
        
        local url="${base_url}${trigger}"
        http_get "$url" "$response_file" >/dev/null 2>&1
        
        local error_content
        error_content=$(cat "$response_file" 2>/dev/null | head -c 5000)
        
        # Analyze error page for framework fingerprints
        analyze_error_content "$error_content" "$target" results
        
        rm -f "$response_file"
    done
}

analyze_error_content() {
    local content="$1"
    local target="$2"
    local -n results=$3
    
    # Spring Boot Whitelabel Error Page
    if echo "$content" | grep -qiE "Whitelabel Error Page|There was an unexpected error"; then
        results+=("MEDIUM:error:spring-boot")
        report_result "$target" "error_fingerprint" "spring4shell" \
            "Whitelabel Error Page" "MEDIUM" "${content:0:300}" \
            "Spring Boot default error page detected - indicates Spring framework"
    fi
    
    # Struts error patterns
    if echo "$content" | grep -qiE "struts|ognl\.OgnlException|ActionSupport"; then
        results+=("HIGH:error:struts")
        report_result "$target" "error_fingerprint" "struts" \
            "Struts error pattern" "HIGH" "${content:0:300}" \
            "Apache Struts error signature detected"
    fi
    
    # Java stack traces
    if echo "$content" | grep -qiE "java\.(lang|io|util)\.|at [a-z]+\.[A-Z].*\(.*\.java:[0-9]+\)"; then
        # Check for specific framework traces
        if echo "$content" | grep -qiE "org\.springframework"; then
            results+=("MEDIUM:error:springframework")
            report_result "$target" "error_fingerprint" "spring4shell" \
                "Spring Framework trace" "MEDIUM" "${content:0:300}" \
                "Spring Framework package in stack trace"
        fi
        
        if echo "$content" | grep -qiE "org\.apache\.logging\.log4j"; then
            results+=("MEDIUM:error:log4j")
            report_result "$target" "error_fingerprint" "log4shell" \
                "Log4j trace" "MEDIUM" "${content:0:300}" \
                "Log4j package in stack trace"
        fi
        
        if echo "$content" | grep -qiE "com\.fasterxml\.jackson"; then
            results+=("MEDIUM:error:jackson")
            report_result "$target" "error_fingerprint" "jackson" \
                "Jackson trace" "MEDIUM" "${content:0:300}" \
                "Jackson package in stack trace"
        fi
    fi
    
    # Node.js error patterns
    if echo "$content" | grep -qiE "at Object\.<anonymous>|at Module\._compile|node_modules"; then
        results+=("LOW:error:nodejs")
        report_result "$target" "error_fingerprint" "vm2" \
            "Node.js error pattern" "LOW" "${content:0:300}" \
            "Node.js stack trace detected - check for vm2 if sandbox functionality present"
    fi
}

#-------------------------------------------------------------------------------
# VERSION EXTRACTION AND COMPARISON UTILITIES
#-------------------------------------------------------------------------------
extract_version_from_json() {
    local json_content="$1"
    local target="$2"
    local -n results=$3
    
    # Try to extract version fields
    local version
    version=$(echo "$json_content" | jq -r '.version // .number // .app_version // empty' 2>/dev/null)
    
    if [[ -n "$version" ]]; then
        # Check against known vulnerable patterns
        
        # Kibana version check
        if echo "$json_content" | grep -qiE "kibana|elasticsearch"; then
            if version_in_range "$version" "5.0.0" "6.6.0"; then
                results+=("HIGH:version:kibana:$version")
                report_result "$target" "version_check" "kibana" \
                    "Kibana $version" "HIGH" "JSON version: $version" \
                    "Kibana version in vulnerable range for CVE-2019-7609"
            fi
        fi
    fi
}

version_in_range() {
    local version="$1"
    local min_version="$2"
    local max_version="$3"
    
    # Simple version comparison using sort -V
    local sorted
    sorted=$(printf '%s\n' "$min_version" "$version" "$max_version" | sort -V)
    
    local first last
    first=$(echo "$sorted" | head -1)
    last=$(echo "$sorted" | tail -1)
    
    [[ "$first" == "$min_version" && "$last" == "$max_version" ]]
}

#-------------------------------------------------------------------------------
# MAIN SCANNING ORCHESTRATOR
#-------------------------------------------------------------------------------
scan_target() {
    local target="$1"
    
    log_info "Starting scan of: $target"
    
    # Normalize target URL
    if [[ ! "$target" =~ ^https?:// ]]; then
        target="https://$target"
    fi
    target="${target%/}"
    
    # Results accumulator for this target
    declare -a target_indicators=()
    
    # Create temp directory for this target
    local work_dir
    work_dir=$(mktemp -d)
    local headers_file="$work_dir/headers.txt"
    
    # Run probes
    probe_headers "$target" "$headers_file" target_indicators || log_warn "Header probe failed for $target"
    probe_endpoints "$target" target_indicators
    probe_dependency_files "$target" target_indicators
    probe_error_pages "$target" target_indicators
    
    # Calculate aggregate confidence
    local aggregate_confidence="NONE"
    if [[ ${#target_indicators[@]} -gt 0 ]]; then
        aggregate_confidence=$(calculate_confidence target_indicators)
    fi
    
    log_info "Scan complete for $target - ${#target_indicators[@]} indicators found (Aggregate: $aggregate_confidence)"
    
    # Cleanup
    rm -rf "$work_dir"
    
    echo "$aggregate_confidence"
}

#-------------------------------------------------------------------------------
# TARGET LIST PROCESSING
#-------------------------------------------------------------------------------
process_targets() {
    local targets_file="$1"
    
    if [[ ! -f "$targets_file" ]]; then
        log_error "Targets file not found: $targets_file"
        exit 1
    fi
    
    local total_targets
    total_targets=$(wc -l < "$targets_file")
    log_info "Processing $total_targets targets with concurrency $CONCURRENCY"
    
    local count=0
    while IFS= read -r target || [[ -n "$target" ]]; do
        # Skip empty lines and comments
        [[ -z "$target" || "$target" =~ ^# ]] && continue
        
        ((count++))
        log_info "[$count/$total_targets] Processing: $target"
        
        scan_target "$target"
        
    done < "$targets_file"
    # TODO: Implement parallel processing with GNU parallel or xargs -P
    # for controlled concurrency (respecting CONCURRENCY variable)
}

#-------------------------------------------------------------------------------
# SUMMARY GENERATION
#-------------------------------------------------------------------------------
generate_summary() {
    log_info "Generating summary report..."
    
    if [[ ! -f "$RESULTS_FILE" ]]; then
        log_warn "No results file found"
        return
    fi
    
    {
        echo "=============================================="
        echo "SAFE RECONNAISSANCE SUMMARY REPORT"
        echo "Generated: $(date -Iseconds)"
        echo "Tool Version: $SCRIPT_VERSION"
        echo "=============================================="
        echo ""
        echo "DISCLAIMER: These are INDICATORS only, not confirmed vulnerabilities."
        echo "Further authorized investigation is required to confirm exploitability."
        echo ""
        echo "----------------------------------------------"
        echo "FINDINGS BY VULNERABILITY CLASS:"
        echo "----------------------------------------------"
        
        for vuln_class in spring4shell log4shell text4shell fastjson jackson struts kibana imagemagick ghostscript vm2; do
            local count high med low
            count=$(grep -c "\"vuln_class\":\"$vuln_class\"" "$RESULTS_FILE" 2>/dev/null || echo 0)
            high=$(grep "\"vuln_class\":\"$vuln_class\"" "$RESULTS_FILE" 2>/dev/null | grep -c '"confidence":"HIGH"' || echo 0)
            med=$(grep "\"vuln_class\":\"$vuln_class\"" "$RESULTS_FILE" 2>/dev/null | grep -c '"confidence":"MEDIUM"' || echo 0)
            low=$(grep "\"vuln_class\":\"$vuln_class\"" "$RESULTS_FILE" 2>/dev/null | grep -c '"confidence":"LOW"' || echo 0)
            
            if [[ $count -gt 0 ]]; then
                echo ""
                echo "[$vuln_class] Total: $count indicators"
                echo "  HIGH: $high | MEDIUM: $med | LOW: $low"
            fi
        done
        
        echo ""
        echo "----------------------------------------------"
        echo "HIGH-CONFIDENCE FINDINGS (Require Immediate Review):"
        echo "----------------------------------------------"
        
        grep '"confidence":"HIGH"' "$RESULTS_FILE" 2>/dev/null | \
            jq -r '[.target, .vuln_class, .indicator] | @tsv' 2>/dev/null | \
            while IFS=$'\t' read -r target vuln indicator; do
                echo "  - $target: $vuln ($indicator)"
            done
        
        echo ""
        echo "=============================================="
        echo "END OF REPORT"
        echo "=============================================="
    } > "$SUMMARY_FILE"
    
    cat "$SUMMARY_FILE"
}

#-------------------------------------------------------------------------------
# USAGE AND MAIN ENTRY POINT
#-------------------------------------------------------------------------------
usage() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS] <targets_file|single_target>

SAFE RECONNAISSANCE MVP - Defensive Indicator Detection

OPTIONS:
    -h, --help          Show this help message
    -v, --verbose       Enable verbose output
    -o, --output DIR    Output directory (default: ./recon_output)
    -r, --rate LIMIT    Requests per second (default: 2)
    -c, --concurrency N Max parallel targets (default: 5)
    --no-robots         Don't respect robots.txt
    --json              Output format: jsonl (default)
    --csv               Output format: csv

EXAMPLES:
    $SCRIPT_NAME targets.txt
    $SCRIPT_NAME -v -r 1 https://example.com
    $SCRIPT_NAME -o /tmp/results --no-robots targets.txt

ETHICS / AUTHORIZATION:
    Do not run this tool against assets for which you do not have explicit
    written authorization. Scanning or testing without permission is illegal.

    This tool performs INDICATOR DETECTION only - it does NOT send exploit
    payloads, attempt command injection, or execute remote payloads.

EOF
    exit 0
}

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                usage
                ;;
            -v|--verbose)
                VERBOSE="true"
                shift
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -r|--rate)
                RATE_LIMIT="$2"
                shift 2
                ;;
            -c|--concurrency)
                CONCURRENCY="$2"
                shift 2
                ;;
            --no-robots)
                RESPECT_ROBOTS="false"
                shift
                ;;
            --json)
                OUTPUT_FORMAT="jsonl"
                shift
                ;;
            --csv)
                OUTPUT_FORMAT="csv"
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                usage
                ;;
            *)
                break
                ;;
        esac
    done
    
    if [[ $# -lt 1 ]]; then
        log_error "No target specified"
        usage
    fi
    
    local target_input="$1"
    
    # Print authorization reminder
    echo ""
    echo "=========================================="
    echo "       AUTHORIZATION REMINDER"
    echo "=========================================="
    echo "You are about to run reconnaissance against: $target_input"
    echo ""
    echo "Confirm you have EXPLICIT WRITTEN AUTHORIZATION"
    echo "to perform security testing against these targets."
    echo ""
    read -p "Type 'AUTHORIZED' to continue: " confirmation
    
    if [[ "$confirmation" != "AUTHORIZED" ]]; then
        log_error "Authorization not confirmed. Exiting."
        exit 1
    fi
    
    # Initialize
    init_output
    
    log_info "Starting Safe Reconnaissance MVP v$SCRIPT_VERSION"
    log_info "Rate limit: $RATE_LIMIT req/s | Concurrency: $CONCURRENCY"
    log_info "Respect robots.txt: $RESPECT_ROBOTS"
    
    # Process targets
    if [[ -f "$target_input" ]]; then
        process_targets "$target_input"
    else
        scan_target "$target_input"
    fi
    
    # Generate summary
    generate_summary
    
    log_info "Results saved to: $RESULTS_FILE"
    log_info "Summary saved to: $SUMMARY_FILE"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
