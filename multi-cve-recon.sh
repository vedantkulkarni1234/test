#!/bin/bash

################################################################################
# Multi-CVE Reconnaissance Script
# 
# PURPOSE:
#   Performs non-destructive recon to identify likely exploitable occurrences of:
#   - Spring4Shell (CVE-2022-22965)
#   - Log4Shell (CVE-2021-44228)
#   - Text4Shell (CVE-2022-42889)
#   - Fastjson RCE (e.g., CVE-2017-18349 and related)
#   - Jackson RCE (e.g., CVE-2019-12384 and related)
#   - Apache Struts 2 RCE (CVE-2017-5638)
#   - Kibana Prototype Pollution RCE (CVE-2019-7609)
#   - Ghostscript RCE via ImageMagick/Node integration
#   - Node.js "vm2" Sandbox Escape (CVE-2023-37466)
#
# DISCLAIMER:
#   This script is for AUTHORIZED SECURITY TESTING ONLY.
#   - Ensure you have explicit authorization before scanning any target.
#   - The script is NON-DESTRUCTIVE and only reads/queries endpoints.
#   - It does NOT guarantee absence of vulnerabilities; only attempts detection.
#   - Some checks may produce false positives; manually verify findings.
#   - Use at your own risk on production systems.
#
# USAGE:
#   ./multi-cve-recon.sh [-f targets.txt] [-t target_url] [-k] [-o output.jsonl]
#
#   -f FILE       Read targets from file (one per line, http://host:port or https://...)
#   -t TARGET     Scan a single target (http://host:port or https://...)
#   -k            Ignore TLS/SSL verification (useful for self-signed certs)
#   -o OUTPUT     Write results to file in JSONL format (default: stdout)
#   -h, --help    Show this help message
#
# EXAMPLES:
#   ./multi-cve-recon.sh -f targets.txt
#   ./multi-cve-recon.sh -t http://example.com:8080 -k
#   ./multi-cve-recon.sh -f targets.txt -o results.jsonl
#
################################################################################

set -o pipefail

###############################################################################
# Configuration and Constants
###############################################################################

SCRIPT_NAME="$(basename "$0")"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Output file (empty = stdout)
OUTPUT_FILE=""

# TLS verification flag
VERIFY_TLS=true

# Timeout for curl requests (seconds)
CURL_TIMEOUT=10

# HTTP headers for spoofing user agents
USER_AGENT="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"

# Color codes for terminal output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Global arrays to track results
declare -A results_confirmed
declare -A results_likely
declare -A results_potential
declare -a targets_list

###############################################################################
# Utility Functions
###############################################################################

# Print help message
print_help() {
    cat <<EOF
${BLUE}Multi-CVE Reconnaissance Script${NC}

${GREEN}USAGE:${NC}
  $SCRIPT_NAME [-f targets.txt] [-t target_url] [-k] [-o output.jsonl]

${GREEN}OPTIONS:${NC}
  -f FILE       Read targets from file (one target per line)
  -t TARGET     Scan a single target
  -k            Ignore TLS/SSL verification
  -o OUTPUT     Write results to file (JSONL format)
  -h, --help    Show this help message

${GREEN}EXAMPLES:${NC}
  $SCRIPT_NAME -f targets.txt
  $SCRIPT_NAME -t http://example.com:8080 -k
  $SCRIPT_NAME -f targets.txt -o results.jsonl

${YELLOW}DISCLAIMER:${NC}
  This tool is for AUTHORIZED security testing only.
  Non-destructive recon only. Always obtain proper authorization.

EOF
}

# Log output to file or stdout
log_output() {
    local message="$1"
    if [[ -n "$OUTPUT_FILE" ]]; then
        echo "$message" >> "$OUTPUT_FILE"
    else
        echo "$message"
    fi
}

# Log to stderr (for status messages, not part of JSON output)
log_status() {
    echo -e "${BLUE}[*]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[!]${NC} $1" >&2
}

# Make a curl request with timeout and TLS handling
curl_request() {
    local url="$1"
    local method="${2:-GET}"
    local data="${3:-}"
    local headers="${4:-}"
    
    local curl_opts=(
        "--silent"
        "--show-error"
        "--max-time" "$CURL_TIMEOUT"
        "--user-agent" "$USER_AGENT"
        "-w" "\n%{http_code}"
    )
    
    if [[ "$VERIFY_TLS" == false ]]; then
        curl_opts+=("-k")
    fi
    
    if [[ -n "$headers" ]]; then
        curl_opts+=("-H" "$headers")
    fi
    
    if [[ "$method" == "POST" ]]; then
        curl_opts+=("-X" "POST")
        if [[ -n "$data" ]]; then
            curl_opts+=("-d" "$data")
        fi
    fi
    
    curl "${curl_opts[@]}" "$url" 2>/dev/null
}

# Extract HTTP status code from curl response
get_http_status() {
    local response="$1"
    echo "$response" | tail -n1
}

# Extract response body from curl response
get_response_body() {
    local response="$1"
    echo "$response" | head -n-1
}

# Normalize URL (ensure scheme, handle trailing slashes)
normalize_url() {
    local url="$1"
    
    # Add http:// if no scheme
    if [[ ! "$url" =~ ^https?:// ]]; then
        url="http://$url"
    fi
    
    # Remove trailing slash
    url="${url%/}"
    
    echo "$url"
}

# Parse JSON response safely
parse_json_field() {
    local json="$1"
    local field="$2"
    
    # Use grep + sed for JSON parsing without external dependencies
    echo "$json" | grep -o "\"$field\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | cut -d'"' -f4
}

###############################################################################
# Vulnerability Check Functions
###############################################################################

# ==============================================================================
# Spring4Shell (CVE-2022-22965)
# ==============================================================================
# DETECTION LOGIC:
#   - Spring4Shell affects Spring Framework versions:
#     5.3.0 through 5.3.17, and 5.2.0 through 5.2.19
#   - Primarily exploitable when processing form submissions with ClassPathXmlApplicationContext
#   - Detection: Look for /actuator endpoints (Spring Boot), version headers, specific behavior
#   - We check for:
#     1. Spring-specific headers or actuator endpoints
#     2. Known vulnerable version ranges
#     3. Vulnerable servlet initialization patterns
# ==============================================================================
check_spring4shell() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Check for Spring actuator endpoint (common in Spring Boot)
    local actuator_response=$(curl_request "$target/actuator/env" "GET")
    local actuator_status=$(get_http_status "$actuator_response")
    local actuator_body=$(get_response_body "$actuator_response")
    
    if [[ "$actuator_status" == "200" ]]; then
        # /actuator/env is a strong indicator of Spring Boot
        if echo "$actuator_body" | grep -q "springVersion\|Spring"; then
            status="likely_vulnerable"
            evidence="Spring actuator endpoint exposed, version info available"
        else
            status="potentially_vulnerable"
            evidence="Spring actuator endpoint accessible"
        fi
    fi
    
    # Check for version info in headers or common endpoints
    local version_response=$(curl_request "$target/" "GET")
    local version_body=$(get_response_body "$version_response")
    
    # Look for Spring version in headers or HTML
    if echo "$version_body" | grep -qiE "Spring[/-]([5][.][2-3]|[5][.][3])" || \
       echo "$version_response" | grep -qiE "Server:.*Spring|X-Application.*Spring"; then
        if [[ "$status" == "not_detected" ]]; then
            status="potentially_vulnerable"
            evidence="Spring Framework detected in response"
        fi
    fi
    
    # Check for Spring expression language processing (EL) endpoints
    local el_test_response=$(curl_request "$target/actuator/health" "GET")
    local el_status=$(get_http_status "$el_test_response")
    
    if [[ "$el_status" == "200" || "$el_status" == "404" ]]; then
        if [[ "$status" == "potentially_vulnerable" ]]; then
            evidence="$evidence; Spring Boot health endpoint"
        fi
    fi
    
    output_result "$target" "CVE-2022-22965" "Spring4Shell" "$status" "$evidence"
}

# ==============================================================================
# Log4Shell (CVE-2021-44228)
# ==============================================================================
# DETECTION LOGIC:
#   - CVE-2021-44228 affects Log4j 2.0.0 through 2.14.1 (and other ranges)
#   - JNDI injection vector: ${jndi:ldap://...} or ${jndi:rmi://...}
#   - Detection strategy:
#     1. Look for Java application identifiers
#     2. Check error pages for Log4j version strings
#     3. Test for JNDI message processing (without actually exploiting)
#     4. Look for log endpoints that accept user input
#   - We use a harmless test string to see if it's logged/processed
# ==============================================================================
check_log4shell() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Test for Java application indicators
    local app_response=$(curl_request "$target/" "GET")
    local app_body=$(get_response_body "$app_response")
    
    # Look for Log4j or Java-specific error patterns
    if echo "$app_body" | grep -qiE "log4j|java.lang|Exception|Throwable" || \
       echo "$app_response" | grep -qiE "X-Powered-By.*Java|Server.*Java"; then
        status="potentially_vulnerable"
        evidence="Java application detected"
    fi
    
    # Look for common logging endpoints that might process user input
    local log_endpoints=("/logs" "/log" "/api/logs" "/debug/logs" "/admin/logs")
    for endpoint in "${log_endpoints[@]}"; do
        local log_response=$(curl_request "$target$endpoint" "GET")
        local log_status=$(get_http_status "$log_response")
        local log_body=$(get_response_body "$log_response")
        
        if [[ "$log_status" == "200" ]] && echo "$log_body" | grep -qiE "log4j|DEBUG|INFO|WARN|ERROR"; then
            status="likely_vulnerable"
            evidence="Logging endpoint detected at $endpoint"
            break
        fi
    done
    
    # Check for Log4j version in error pages or known paths
    local version_response=$(curl_request "$target/error" "GET")
    local version_body=$(get_response_body "$version_response")
    
    if echo "$version_body" | grep -qiE "log4j.*[2][.](0|1[0-4]|15)"; then
        status="confirmed_vulnerable"
        evidence="Log4j vulnerable version detected"
    elif echo "$version_body" | grep -qiE "log4j"; then
        status="likely_vulnerable"
        evidence="Log4j presence detected in error page"
    fi
    
    output_result "$target" "CVE-2021-44228" "Log4Shell" "$status" "$evidence"
}

# ==============================================================================
# Text4Shell (CVE-2022-42889)
# ==============================================================================
# DETECTION LOGIC:
#   - Affects Apache Commons Text 1.5 through 1.9
#   - StringSubstitutor with recursive interpolation vulnerability
#   - Detection focuses on:
#     1. Identifying applications using Apache Commons Text
#     2. Testing endpoints that perform string interpolation/templating
#     3. Looking for version indicators
#   - Low-risk test: submit a simple marker string
# ==============================================================================
check_text4shell() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Look for known applications that use Apache Commons Text
    # Common frameworks: Play Framework, Apache Struts, custom Java apps
    local app_response=$(curl_request "$target/" "GET")
    local app_body=$(get_response_body "$app_response")
    
    # Check for commons text indicators
    if echo "$app_response" | grep -qiE "X-Powered-By|Server" && \
       echo "$app_response" | grep -qiE "Java|Play|Struts"; then
        status="potentially_vulnerable"
        evidence="Potential Apache Commons library application"
    fi
    
    # Test common endpoints that might use text substitution
    local text_endpoints=("/api/interpolate" "/api/template" "/api/process" "/api/format")
    for endpoint in "${text_endpoints[@]}"; do
        local test_payload='${prefix:suffix}'  # Benign string interpolation test
        local response=$(curl_request "$target$endpoint" "POST" "$test_payload" "Content-Type: application/x-www-form-urlencoded")
        local http_status=$(get_http_status "$response")
        
        # If endpoint exists and processes the input, it may use string substitution
        if [[ "$http_status" != "404" && "$http_status" != "405" ]]; then
            status="potentially_vulnerable"
            evidence="Text processing endpoint found at $endpoint"
        fi
    done
    
    # Check for version indicators
    local version_response=$(curl_request "$target/api/version" "GET")
    local version_body=$(get_response_body "$version_response")
    
    if echo "$version_body" | grep -qiE "commons.text|commons-text"; then
        status="likely_vulnerable"
        evidence="Apache Commons Text library detected"
    fi
    
    output_result "$target" "CVE-2022-42889" "Text4Shell" "$status" "$evidence"
}

# ==============================================================================
# Fastjson RCE (CVE-2017-18349 and related)
# ==============================================================================
# DETECTION LOGIC:
#   - Fastjson (Alibaba JSON library) versions <1.2.42 vulnerable
#   - Uses reflection to instantiate classes, leading to RCE
#   - Detection:
#     1. Look for JSON endpoints
#     2. Check for Fastjson in headers/errors
#     3. Test for type-based deserialization indicators
#   - No actual RCE payload; just detect presence and configuration
# ==============================================================================
check_fastjson_rce() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Look for JSON API endpoints
    local json_endpoints=("/api/data" "/api/user" "/api/config" "/api/json" "/service/data")
    
    for endpoint in "${json_endpoints[@]}"; do
        local test_json='{"test":"value"}'
        local response=$(curl_request "$target$endpoint" "POST" "$test_json" "Content-Type: application/json")
        local http_status=$(get_http_status "$response")
        
        # If endpoint accepts JSON and responds, check for Fastjson indicators
        if [[ "$http_status" != "404" && "$http_status" != "405" ]]; then
            local body=$(get_response_body "$response")
            
            if echo "$response" | grep -qiE "X-Fastjson|Fastjson|alibaba"; then
                status="confirmed_vulnerable"
                evidence="Fastjson explicitly identified in headers"
                break
            elif echo "$body" | grep -qiE "@type|autoType"; then
                status="likely_vulnerable"
                evidence="Fastjson autoType pattern detected in response"
                break
            elif [[ "$http_status" == "200" ]] && echo "$body" | grep -qiE "^{.*}$|^\[.*\]$"; then
                status="potentially_vulnerable"
                evidence="JSON endpoint accessible at $endpoint"
            fi
        fi
    done
    
    # Check for CVE-2017-18349 specific patterns
    local version_response=$(curl_request "$target/api/version" "GET")
    if echo "$version_response" | grep -qiE "fastjson.*([0-9]\.[0-9]\.[0-9])"; then
        status="likely_vulnerable"
        evidence="Fastjson version detected"
    fi
    
    output_result "$target" "CVE-2017-18349" "Fastjson RCE" "$status" "$evidence"
}

# ==============================================================================
# Jackson RCE (CVE-2019-12384 and related)
# ==============================================================================
# DETECTION LOGIC:
#   - Jackson versions before 2.9.8.1, 2.8.11.2 vulnerable
#   - Polymorphic deserialization vulnerability
#   - Detection:
#     1. Check for Jackson in responses/headers
#     2. Look for polymorphic type hints in JSON
#     3. Test JSON endpoints for type-based processing
# ==============================================================================
check_jackson_rce() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Test JSON endpoints (Jackson is commonly used in REST APIs)
    local json_endpoints=("/api/parse" "/api/data" "/api/object" "/api/rest")
    
    for endpoint in "${json_endpoints[@]}"; do
        # Benign JSON with type hint (no actual exploit)
        local test_json='{"@class":"com.example.Class","value":"test"}'
        local response=$(curl_request "$target$endpoint" "POST" "$test_json" "Content-Type: application/json")
        local http_status=$(get_http_status "$response")
        local body=$(get_response_body "$response")
        
        if [[ "$http_status" != "404" && "$http_status" != "405" ]]; then
            # Check for Jackson indicators
            if echo "$response" | grep -qiE "X-Jackson|Jackson|com.fasterxml"; then
                status="confirmed_vulnerable"
                evidence="Jackson explicitly detected in headers"
                break
            elif echo "$body" | grep -qiE "@class|jackson|fasterxml"; then
                status="likely_vulnerable"
                evidence="Jackson polymorphic deserialization detected"
                break
            elif [[ "$http_status" == "200" ]] && echo "$body" | grep -qiE "^{.*}$"; then
                status="potentially_vulnerable"
                evidence="JSON endpoint accessible at $endpoint"
            fi
        fi
    done
    
    output_result "$target" "CVE-2019-12384" "Jackson RCE" "$status" "$evidence"
}

# ==============================================================================
# Apache Struts 2 RCE (CVE-2017-5638)
# ==============================================================================
# DETECTION LOGIC:
#   - CVE-2017-5638 affects Struts 2.3.5 through 2.5.10
#   - OGNL expression injection in Content-Type header
#   - Detection:
#     1. Check for Struts 2 indicators (URL patterns, headers)
#     2. Look for struts2 specific error pages
#     3. Check known vulnerable paths like /struts2-showcase
# ==============================================================================
check_struts2_rce() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Check for Struts 2 specific indicators
    # Common paths: /struts2-showcase, *.action, *.do
    local struts_paths=("" "/struts2-showcase" "/showcase" "/example" "/demo")
    
    for path in "${struts_paths[@]}"; do
        local response=$(curl_request "$target$path" "GET")
        local http_status=$(get_http_status "$response")
        local body=$(get_response_body "$response")
        
        if [[ "$http_status" == "200" ]]; then
            if echo "$body" | grep -qiE "struts|Struts2|OGNL|OpenSymphony"; then
                status="likely_vulnerable"
                evidence="Struts 2 detected at $path"
                break
            elif echo "$response" | grep -qiE "X-Struts|Struts-Version"; then
                status="confirmed_vulnerable"
                evidence="Struts version detected in headers"
                break
            fi
        fi
    done
    
    # Test for OGNL processing via action endpoints
    local action_endpoints=("/login.action" "/search.action" "/api.action" "/admin.action")
    for action in "${action_endpoints[@]}"; do
        local response=$(curl_request "$target$action" "GET")
        local http_status=$(get_http_status "$response")
        
        if [[ "$http_status" == "200" || "$http_status" == "302" ]]; then
            status="potentially_vulnerable"
            evidence="Struts action endpoint found at $action"
            break
        fi
    done
    
    output_result "$target" "CVE-2017-5638" "Apache Struts 2 RCE" "$status" "$evidence"
}

# ==============================================================================
# Kibana Prototype Pollution RCE (CVE-2019-7609)
# ==============================================================================
# DETECTION LOGIC:
#   - Affects Kibana versions 5.0.0 through 5.6.13, 6.0.0 through 6.5.3
#   - Prototype pollution in Canvas plugin or other endpoints
#   - Detection:
#     1. Check for Kibana-specific endpoints (/app/kibana, /api/kibana)
#     2. Look for Kibana in headers or version info
#     3. Check vulnerable version patterns
# ==============================================================================
check_kibana_rce() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Check for Kibana specific endpoints
    local kibana_endpoints=("/app/kibana" "/api/kibana" "/api/saved_objects" "/app")
    
    for endpoint in "${kibana_endpoints[@]}"; do
        local response=$(curl_request "$target$endpoint" "GET")
        local http_status=$(get_http_status "$response")
        local body=$(get_response_body "$response")
        
        if [[ "$http_status" == "200" ]]; then
            if echo "$body" | grep -qiE "kibana|Kibana"; then
                status="potentially_vulnerable"
                evidence="Kibana application detected at $endpoint"
                break
            fi
        fi
    done
    
    # Check version endpoint specifically for Kibana
    local version_response=$(curl_request "$target/api/status" "GET")
    local version_body=$(get_response_body "$version_response")
    
    if echo "$version_body" | grep -qiE "version.*:.*\"[5-6]\.[0-9]"; then
        # Extract version
        if echo "$version_body" | grep -qiE "version.*:.*\"([5-6]\.[0-6])"; then
            status="likely_vulnerable"
            evidence="Kibana vulnerable version detected"
        elif echo "$version_body" | grep -qiE "kibana"; then
            status="potentially_vulnerable"
            evidence="Kibana version endpoint found"
        fi
    fi
    
    output_result "$target" "CVE-2019-7609" "Kibana Prototype Pollution RCE" "$status" "$evidence"
}

# ==============================================================================
# Ghostscript RCE via ImageMagick/Node integration (CVE-2019-11358 related)
# ==============================================================================
# DETECTION LOGIC:
#   - Ghostscript RCE typically affects systems with ImageMagick or Node.js integration
#   - Detection focuses on:
#     1. Identify applications that process PDF/image files
#     2. Look for ImageMagick or Ghostscript indicators
#     3. Check for file upload endpoints that might use these tools
# ==============================================================================
check_ghostscript_rce() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Look for file upload endpoints
    local upload_endpoints=("/upload" "/api/upload" "/file/upload" "/images/upload" "/api/image")
    
    for endpoint in "${upload_endpoints[@]}"; do
        local response=$(curl_request "$target$endpoint" "POST" "" "Content-Type: multipart/form-data")
        local http_status=$(get_http_status "$response")
        
        if [[ "$http_status" != "404" && "$http_status" != "405" ]]; then
            # Endpoint exists and accepts POST
            status="potentially_vulnerable"
            evidence="File upload endpoint detected at $endpoint"
            break
        fi
    done
    
    # Check for ImageMagick indicators in headers or responses
    local app_response=$(curl_request "$target/" "GET")
    local app_body=$(get_response_body "$app_response")
    
    if echo "$app_response" | grep -qiE "ImageMagick|Ghostscript|X-Image-Processor"; then
        if [[ "$status" == "potentially_vulnerable" ]]; then
            evidence="$evidence; ImageMagick/Ghostscript detected"
            status="likely_vulnerable"
        else
            status="potentially_vulnerable"
            evidence="ImageMagick/Ghostscript support detected"
        fi
    fi
    
    # Check for common image processing endpoints
    if echo "$app_body" | grep -qiE "pdf|image|convert|process"; then
        if [[ "$status" == "not_detected" ]]; then
            status="potentially_vulnerable"
            evidence="Image/PDF processing indicators detected"
        fi
    fi
    
    output_result "$target" "CVE-2019-11358" "Ghostscript RCE" "$status" "$evidence"
}

# ==============================================================================
# Node.js "vm2" Sandbox Escape (CVE-2023-37466)
# ==============================================================================
# DETECTION LOGIC:
#   - CVE-2023-37466 affects vm2 < 3.9.10
#   - Node.js applications using vm2 for code sandboxing
#   - Detection:
#     1. Look for Node.js applications (headers, endpoints)
#     2. Check for code execution or sandbox endpoints
#     3. Look for vm2 version in package info or error messages
# ==============================================================================
check_vm2_rce() {
    local target="$1"
    local status="not_detected"
    local evidence=""
    
    # Check for Node.js indicators
    local app_response=$(curl_request "$target/" "GET")
    local app_body=$(get_response_body "$app_response")
    local app_headers=$(echo "$app_response" | head -n-1)
    
    if echo "$app_headers" | grep -qiE "X-Powered-By.*Node|Node.js|Express"; then
        status="potentially_vulnerable"
        evidence="Node.js application detected"
    fi
    
    # Check for sandbox/execution endpoints
    local sandbox_endpoints=("/api/sandbox" "/api/execute" "/api/eval" "/api/run" "/api/code" "/sandbox")
    
    for endpoint in "${sandbox_endpoints[@]}"; do
        local test_payload='console.log("test")'
        local response=$(curl_request "$target$endpoint" "POST" "$test_payload" "Content-Type: application/json")
        local http_status=$(get_http_status "$response")
        
        if [[ "$http_status" != "404" && "$http_status" != "405" ]]; then
            status="likely_vulnerable"
            evidence="Code execution/sandbox endpoint detected at $endpoint"
            break
        fi
    done
    
    # Check for vm2 version info
    local version_response=$(curl_request "$target/api/version" "GET")
    local version_body=$(get_response_body "$version_response")
    
    if echo "$version_body" | grep -qiE "vm2"; then
        status="likely_vulnerable"
        evidence="vm2 package detected"
    fi
    
    # Check package.json if accessible
    local package_response=$(curl_request "$target/package.json" "GET")
    local package_body=$(get_response_body "$package_response")
    
    if echo "$package_body" | grep -qiE '"vm2"'; then
        status="confirmed_vulnerable"
        evidence="vm2 found in package.json"
    elif echo "$package_body" | grep -qiE "vm2.*([0-3]\.[0-8]|3\.9\.[0-9])" && \
         ! echo "$package_body" | grep -qiE "vm2.*3\.9\.10"; then
        status="confirmed_vulnerable"
        evidence="vm2 vulnerable version detected in package.json"
    fi
    
    output_result "$target" "CVE-2023-37466" "vm2 Sandbox Escape" "$status" "$evidence"
}

# ==============================================================================
# Output Result (JSON format)
# ==============================================================================
output_result() {
    local target="$1"
    local cve_id="$2"
    local vuln_name="$3"
    local status="$4"
    local evidence="$5"
    
    # Build JSON object
    local json_result=$(cat <<EOF
{"target":"$target","cve_id":"$cve_id","name":"$vuln_name","status":"$status","evidence":"$evidence"}
EOF
)
    
    log_output "$json_result"
    
    # Track results for summary
    case "$status" in
        confirmed_vulnerable)
            results_confirmed["$cve_id"]=$((${results_confirmed["$cve_id"]:-0} + 1))
            ;;
        likely_vulnerable)
            results_likely["$cve_id"]=$((${results_likely["$cve_id"]:-0} + 1))
            ;;
        potentially_vulnerable)
            results_potential["$cve_id"]=$((${results_potential["$cve_id"]:-0} + 1))
            ;;
    esac
}

# ==============================================================================
# Scan a Single Target
# ==============================================================================
scan_target() {
    local target="$1"
    
    # Normalize URL
    target=$(normalize_url "$target")
    
    log_status "Scanning: $target"
    
    # Run all vulnerability checks
    check_spring4shell "$target"
    check_log4shell "$target"
    check_text4shell "$target"
    check_fastjson_rce "$target"
    check_jackson_rce "$target"
    check_struts2_rce "$target"
    check_kibana_rce "$target"
    check_ghostscript_rce "$target"
    check_vm2_rce "$target"
}

# ==============================================================================
# Print Summary
# ==============================================================================
print_summary() {
    echo "" >&2
    echo -e "${BLUE}=== Scan Summary ===${NC}" >&2
    echo "" >&2
    
    local cves=("CVE-2022-22965" "CVE-2021-44228" "CVE-2022-42889" "CVE-2017-18349" \
                 "CVE-2019-12384" "CVE-2017-5638" "CVE-2019-7609" "CVE-2019-11358" "CVE-2023-37466")
    
    for cve in "${cves[@]}"; do
        local confirmed=${results_confirmed["$cve"]:-0}
        local likely=${results_likely["$cve"]:-0}
        local potential=${results_potential["$cve"]:-0}
        
        if [[ $confirmed -gt 0 || $likely -gt 0 || $potential -gt 0 ]]; then
            printf "%-20s | ${RED}Confirmed: %2d${NC} | ${YELLOW}Likely: %2d${NC} | Potential: %2d\n" \
                "$cve" "$confirmed" "$likely" "$potential" >&2
        fi
    done
    
    echo "" >&2
}

###############################################################################
# Main Script Logic
###############################################################################

main() {
    local targets_file=""
    local single_target=""
    
    # Parse command-line arguments
    while getopts "f:t:ko:h" opt; do
        case $opt in
            f)
                targets_file="$OPTARG"
                ;;
            t)
                single_target="$OPTARG"
                ;;
            k)
                VERIFY_TLS=false
                ;;
            o)
                OUTPUT_FILE="$OPTARG"
                # Clear file if it exists
                > "$OUTPUT_FILE"
                ;;
            h)
                print_help
                exit 0
                ;;
            *)
                echo "Unknown option: -$OPTARG" >&2
                print_help
                exit 1
                ;;
        esac
    done
    
    # Validate input
    if [[ -z "$targets_file" && -z "$single_target" ]]; then
        log_error "No targets specified. Use -f for file or -t for single target."
        print_help
        exit 1
    fi
    
    # Load targets from file if specified
    if [[ -n "$targets_file" ]]; then
        if [[ ! -f "$targets_file" ]]; then
            log_error "Targets file not found: $targets_file"
            exit 1
        fi
        
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            targets_list+=("$line")
        done < "$targets_file"
    fi
    
    # Add single target if specified
    if [[ -n "$single_target" ]]; then
        targets_list+=("$single_target")
    fi
    
    # Validate targets array
    if [[ ${#targets_list[@]} -eq 0 ]]; then
        log_error "No valid targets found."
        exit 1
    fi
    
    log_status "Found ${#targets_list[@]} target(s) to scan"
    log_status "Starting multi-CVE reconnaissance..."
    
    if [[ "$VERIFY_TLS" == false ]]; then
        log_status "TLS verification disabled"
    fi
    
    echo "" >&2
    
    # Scan each target
    for target in "${targets_list[@]}"; do
        scan_target "$target"
    done
    
    # Print summary
    print_summary
}

# Run main function with all arguments
main "$@"
